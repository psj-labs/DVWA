# Command Injection

- **Command Injection은 사용자 입력값이 검증 없이 시스템 쉘 명령으로 실행되어 공격자가 임의의 명령을 실행할 수 있는 취약점입니다.**

## 정상 동작 확인

- 입력값으로 `1.1.1.1`을 입력하면 서버는 다음 명령을 실행합니다.

```bash
ping 1.1.1.1
```

- 이는 서버에서 대상 IP로 ping 테스트를 수행하는 정상 동작입니다.

![1.1.1.1](/Low/Command%20Injection/imgs/1.1.1.1.png)

## Command Injection 연산자 비교
- command injection을 설명하기 전에 연산자에 대해 표를 사용하여 간단하게 설명합니다.

| 기호 | 이름 | 실행 조건 | 동작 방식 | 핵심 의미 |
|---|---|---|---|---|
| `;` | 세미콜론 | 항상 실행 | 앞 명령의 성공/실패와 무관하게 뒤 명령 실행 | 무조건 연속 실행 |
| `&` | 앰퍼샌드 | 항상 실행 | 앞 명령을 백그라운드로 실행 후 즉시 뒤 명령 실행 | 병렬 실행 |
| `&&` | 논리 AND | 앞 명령 **성공 시** | 성공해야만 뒤 명령 실행 | 성공 조건 실행 |
| `\|` | 파이프 | 항상 실행 | 앞 명령의 출력(stdout)을 뒤 명령의 입력(stdin)으로 전달 | 데이터 전달 |
| `\|\|` | 논리 OR | 앞 명령 **실패 시** | 실패했을 때만 뒤 명령 실행 | 실패 조건 실행 |

- 필자는 이번 poc에서 `&`연산자를 사용합니다.

## **백그라운드 실행**
- 명령을 실행한 뒤 결과를 기다리지 않고 즉시 다음 명령을 실행하는 방식입니다.

- 사용자 입력을 그대로 쉘 명령에 포함시키기 때문에 다음과 같은 입력이 가능합니다.

```text
1.1.1.1 & [임의 명령]
```
## 다음과 같은 명령어들을 수행 해보았습니다.
### 실행 사용자 확인

```text
1.1.1.1 & whoami
```

![whoami](/Low/Command%20Injection/imgs/whoami.png)

### 임의 문자열 출력

```text
1.1.1.1 & echo 'test'
```

![echo](/Low/Command%20Injection/imgs/echo.png)

### 디렉터리 정보 확인

```text
1.1.1.1 & ls -la
```

![ls-la](/Low/Command%20Injection/imgs/ls-la.png)

### 시스템 계정 정보 노출

```text
1.1.1.1 & cat /etc/passwd
```

![passwd](/Low/Command%20Injection/imgs/passwd.png)

### 해당 파일을 통해 다음 정보가 노출되었습니다.
- 시스템 사용자 계정 목록
- 로그인 가능 여부
- 기본 쉘 정보

## 취약점 발생 원인

- 사용자 입력값에 대한 검증 미흡
- 입력값을 쉘 명령어에 그대로 포함
- 명령 구분자(`&`, `;` 등) 필터링 부재


## *이 취약점을 악용할 경우 다음과 같은 공격이 가능합니다.*

- 시스템 정보 수집
- 중요 파일 탈취
- 서비스 장애 유발
- 권한 상승 시도
- 추가 공격을 위한 초기 침투

--- 

## Command Injection 예방법

- Command Injection 취약점은 사용자 입력값이 **운영체제 쉘 명령으로 해석되는 구조**에서 발생합니다.  
- 따라서 핵심 예방법은 **“사용자 입력이 절대 명령이 되지 않도록 하는 것”**입니다.

## 사용자 입력값 검증 (Input Validation)

- 가장 기본적인 대응 방법은 입력값을 **허용된 형식만 통과시키는 방식(화이트리스트)** 으로 검증하는 것입니다.

### 예시는 다음과 같습니다.

- IP 주소 입력창인 경우  
  → 숫자(`0-9`)와 점(`.`)만 허용합니다.
- 쉘 메타문자를 차단합니다.  
  → `;`, `&`, `|`, `&&`, `||`, `` ` ``, `$()`

- 입력값이 규칙을 조금이라도 벗어날 경우 명령 실행 자체를 거부해야 합니다.

## 쉘을 거치지 않는 명령 실행 방식 사용

- Command Injection의 근본 원인은 `system()`, `exec()`, `shell_exec()` 등 **쉘을 거쳐 명령을 실행하는 함수 사용**에 있습니다.

### 대응 방법은 다음과 같습니다.

- 쉘을 사용하지 않는 API를 사용합니다.
- 명령과 인자를 명확히 분리하여 전달합니다.

즉,  
`ping " + user_input` 와 같은 문자열 결합 방식은 사용해서는 안 됩니다.

## 명령어 고정 및 인자 분리

- 명령어는 **서버 측에서 고정**하고 사용자 입력값은 **인자로만 전달**해야 합니다.

### 잘못된 구조는 다음과 같습니다.

```text
system("ping " + user_input)
```

### 올바른 개념은 다음과 같습니다.

```text
- ping 명령은 서버에서 고정
- 사용자 입력값은 인자로만 처리
```
